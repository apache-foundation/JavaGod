[TOC]

# 基础 	

## 泛型

Java的泛型是伪泛型，**在编译期间**，所有的泛型信息都会被**擦掉**。生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。

如在代码中定义`List<Object>`和`List<String>`等类型，在编译后都会变成`List`，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。

### 一个简单问题

```
 public static void main(String[] args) {
        ArrayList<String> l1=new ArrayList<>();
        ArrayList<Integer> l2=new ArrayList<>();
        l1.add("1");
        l2.add(1);
        System.out.println(l1.getClass()==l1.getClass());
    }
```

答案是true，因为泛型会进行类型消除。



### 当泛型遇上重载


	
```java
public static void method(List<String> list) {
		System.out.println("method(List<String> list)");
}
public static void method(List<Integer> list) {
	System.out.println("method(List<Integer> list)");
}
```


编译不通过，因为泛型只是语法糖，参数List<String> list和List<Integer> list编译之后都被擦除了，变成了一样的原生类型List<E>,擦除动作导致这两种方法的特征签名变得一模一样。

```java
public static String method(List<String> list) {
	System.out.println("method(List<String> list)");
	return "";
}

public static int method(List<Integer> list) {
	System.out.println("method(List<Integer> list)");
	return 1;
}
public static void main(String[] args) {
	method(new ArrayList<String>());
	method(new ArrayList<Integer>());
}
```


运行结果：
method(List<String> list)
method(List<Integer> list)

可见运行成功了。

两个方法的差别主要在于返回值不同。但是重载必须是两个方法方法签名不同，而与返回值无关，返回值并不包含在方法签名里。所以上面代码并不是发生了方法重载。

在Class文件格式中，特征签名的范围更大一些，只要描述符（作用是描述方法的参数列表和返回值）不是完全一致的两个方法就可以共存。也就是说，两个方法如果有相同的名称和特征签名，但返回值不同，那它们也是可以合法地共存在一个Class文件中的，只是没有发生重载。



# 

## jvm运行时数据区？谈谈1.7永久代被移除

​                                ![1564542129113](C:\Users\home.11\AppData\Roaming\Typora\typora-user-images\1564542129113.png)                 

程序计数器有两个作用

1. 字节码解释器通过改变程序计数器的值来实现代码的流程控制
2. 为了在线程切换后每条线程都能正确回到上次执行的位置，因为每条线程都有自己的程序计数器。

虚拟机栈是**存放Java方法**内存模型，每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法返回地址等信息。方法的开始调用对应着栈帧的进栈，方法执行完成对应这栈帧的出栈。位于栈顶被称为“当前方法”。

本地方法栈和虚拟机栈类似，不过虚拟机栈针对Java方法，而本地方法栈针对Native方法。

Java堆。对象实例被分配内存的地方，也是垃圾回收的主要区域。

方法区。存放被虚拟机加载的**类信息、常量final、静态变量static、即时编译期编译后的代码**。
1.7之前方法区是用永久代实现的。
这个区域的内存回收目标主要是针对常量池的回收和类型的卸载。
运行时常量池是方法区的一部分，运行时常量池是Class文件中的一项信息，存放编译期生成的各种字面量和符号引用。

常量池在JDK6之前存于永久代中，而后被移动到了堆中，这是因为永久代空间有限，如果频繁创建字符串对象会使得字符串常量池被挤爆，进而引发永久代异常。

j**dk1.7永久代被移除，** **方法区移至Metaspace，字符串常量移至Java Heap**。元空间的本质和永久代类似，都是对JVM规范中**方法区的实现**。不过元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**。



![1564552178623](C:\Users\home.11\AppData\Roaming\Typora\typora-user-images\1564552178623.png)

**替换的好处**：一、字符串存在永久代中，容易出现性能问题和内存溢出。而元空间用户内存有多大就可以用多大。

二、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低

### 从一个完整的类来看Java内存结构

```
public class HelloWorld {
    private String name;//成员变量等类信息存在元空间

    public void sayHello() {//方法等类信息存在元空间
        System.out.println("Hello"+name);
    }

    public void sayHello(String name) {//方法等类信息存在元空间
        this.name = name;
    }

    public static void main(String[] args) {//main对应虚拟机栈中的一个栈帧
        int a=1;//局部变量存在虚拟机栈的局部变量表
        HelloWorld hw=new HelloWorld();//生成的实例存储在堆，此外hw这个地址的引用存在局部变量表
        hw.setName("test");//？先生成一个“test”字符串对象，然后把值存在堆中
        hw.sayHello();//调用sayHello方法，对应虚拟机栈中的一个栈帧
    }

}
```

以JDK8来分析

元空间：HelloWorld的类信息包括成员变量name、方法sayHello和sayHello会存储在元空间；还有System类

堆：HelloWorld hw=new HelloWorld();会在堆中创建一个HelloWorld的实例；String（“test”）；

虚拟机栈：“test”引用变量；“hw”保存HelloWorld实例的地址引用变量；局部变量a=1；









## jvm运行时数据区中的堆和栈

- **静态存储**——是指在编译时就能够确定每个数据目标在运行时的存储空间需求，因而在编译时就可以给它们分配固定的内存空间。不允许有可变数据结构、嵌套或者递归，因为它们都会导致编译程序无法计算准确的存储空间。
- **栈式存储**——该分配可成为动态存储分配，是由一个类似于堆栈的运行栈来实现的，和静态存储的分配方式相反，在栈式存储方案中，程序对数据区的需求在编译时是完全未知的，只有到了运行的时候才能知道，但是规定在运行中进入一个程序模块的时候，必**须知道该程序模块所需要的数据区的大小**才能分配其内存。和我们在数据结构中所熟知的栈一样，栈式存储分配按照先进后出的原则进行分配。
- **堆式存储**——堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配，比如可变长度串和对象实例，堆由大片的可利用块或空闲块组成，堆中的内存可以按照任意顺序分配和释放。



### 联系

数组或对象在堆创建之后，可以在栈中定义一个特殊的变量，**它取值等于数组或对象在堆内存中的首地址**，栈中的这个变量就成了数组或对象的**引用变量**，它相当于为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。  引用变量相当于为数组或者对象起的一个别名，或者代号。实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针。

引用变量是普通变量，定义时在栈中分配内存，**引用变量在程序运行到作用域外释放**。而数组或对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，**数组和对象在没有引用变量指向它的时候，才变成垃圾**，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。

### 区别

1. 管理方式：堆GC回收，栈方法结束自动释放
2. 存储内容：堆存放对象、栈存放方法
3. 空间大小：堆比栈大
4. 碎片相关：堆碎片更多，毕竟栈是一个简单的单向存储结构
5. 分配方式：堆只支持动态分配，栈支持静态分配和动态分配。
6. 效率：堆比栈效率低，栈就入栈出栈两个操作

## 一个方法被调用的过程？

```
     public  int s() {
        int i=100;
        int j=300;
        int k=i+j;
        return k;
    }
  对应的字节码
  public int s();
    Code:
       0: bipush        100
       2: istore_1
       3: sipush        300
       6: istore_2
       7: iload_1
       8: iload_2
       9: iadd
      10: istore_3
      11: iload_3
      12: ireturn
```



赋值：bipush200被加载进**操作数栈**中，istore将100放入**局部变量表**的第一个Slot中。之后的200也是同样操作。

操作：iload_1好iload_2将100和200分别被压入**操作数栈**中，iadd两个栈顶元素出栈做**整形加法**，istore_3将300这个结果放入**局部变量表**第三个Slot中，300入操作数栈。ireturn返回。

整个运算过程中间变量都以操作数栈的入栈出栈作为信息交换途径。

# 垃圾回收

## 新生代和老年代是什么？对象如何进入老年代？

Java堆分为新生代和老年代。在新生代又被划分为Eden区，From Sruvivor和To Survivor区，比例是8:1:1，所以新生代可用空间其实只有其容量的90%。对象优先被分配在Eden区。

-  **长期存活的对象会进入老年代。**在Eden区出生的对象经过一次Minor GC会若存活，且Survivor区容纳得下，就会进入Survivor区且对象年龄加1，当对象年龄达到一定的值，就会进入老年代。
-  **大对象**比如长字符串、数组由于需要大量连续的内存空间，所以直接进入老年代。这是对象进入老年代的一种方式，
-  若Survivor区不能容纳存活的对象，则会通过**分配担保机制**转移到老年代。
- **同年龄的对象达到suivivor空间的一半**，大于等于该年龄的对象会直接进入老年代。


## 新生代的和老年代什么时候会发生GC？

发生在新生代的GC称为Minor GC，当Eden区被占满了而又需要分配内存时，会发生一次Minor GC，一般使用复制算法，将Eden和From Survivor区中还存活的对象一起复制到To Survivor区中，然后一次性清理掉Eden和From Survivor中的内存，使用复制算法不会产生碎片。

老年代的GC称为Full GC或者Major GC：

- 当老年代的内存占满而又需要分配内存时，会发起Full GC

- 调用System.gc()时，可能会发生Full GC，并不保证一定会执行。

-  在Minor GC后survivor区放不下，**通过担保机制进入老年代的对象比老年代的内存空间还大**，会发生Full GC；

- ·在发生Minor GC之前，会先比较历次晋升到老年代的对象平均年龄，如果大于老年代的内存，也会触发Full GC。如果不允许担保失败，直接Full GC。


## 对象在什么时候可以被回收？调用finalize方法后一定会被回收吗？

在经过可达性分析后，到GC Roots不可达的对象可以被回收（但并不是一定会被回收，至少要经过两次标记），此时对象被第一次标记，并进行一次判断：

如果该对象没有调用过或者没有重写finalize()方法，那么在第二次标记后可以被回收了；

否则，该对象会进入一个FQueue中，稍后由JVM建立的一个Finalizer线程中去执行回收，此时若对象中finalize中“自救”，即和引用链上的任意一个对象建立引用关系，到GC Roots又可达了，在第二次标记时它会被移除“即将回收”的集合；如果finalize中没有逃脱，那就面临被回收。

因此finalize方法被调用后，对象不一定会被回收。

## GC一定会导致停顿吗，为什么一定要停顿？任意时候都可以GC吗还是在特定的时候？

GC进行时必须暂停所有Java执行线程，这被称为Stop The World。为什么要停顿呢？因为可达性分析过程中不允许对象的引用关系还在变化，否则可达性分析的准确性就无法得到保证。所以需要STW以保证可达性分析的正确性。

程序执行时并非在所有地方都能停顿下来开始GC，只有在“安全点”才能暂停。安全点指的是：HotSpot没有为每一条指令都生成OopMap（Ordinary Object Pointer），而是在一些特定的位置记录了这些信息。这些位置就叫安全点。

 安全点表示所有的工作线程都停了

## 哪些对象可以作为GC Roots？

- 虚拟机栈中引用的对象（栈帧中的本地变量表）

- 方法区中类静态属性引用的对象（static）

- 方法区中常量引用的对象（final）

- 本地方法栈中引用的对象




## 讲一讲垃圾回收算法？

**复制算法**，将内存分为对象面和空闲面，每次只使用一块，当需要回收的时候把存活对象移动到另一块。这一块就可以全部清除。当存活对象少的时候，复制算法效率高，所以一般用于**新生代**，新生代中又分为Eden区、from survivor区和to survivor区，默认8:1:1，对象默认创建在Eden区。

优点：1.没有内存碎片。2.顺序分配内存，指针碰撞。

问：为什么新生代有两块survivor区，并且在ygc的时候要把Eden区和from survivor区还存活的对象一并复制到to survivor区？

因为如果只有一块survivor区，虽然从Eden复制过来的对象是连续的，但survivor区域自己也会经历YGC，便**会产生不连续的空间碎片**。这样就有两个弊端1.当大对象来时候，尽管内存还没有填满但因为没有连续内存了不得不提前进行一次FullGC 2.如果内存是不连续的就无法使用指针碰撞。即分配内存的时候只需要维护一个指针即可，而不用维护一个空闲链表。

**标记清除**， 一般用于老年代的垃圾回收。分为两阶段，首先从GC Roots进行扫描，把存活的对象进行标记。标记完成后对堆内存进行线性遍历，回收不可达的对象。缺点1.**空间问题**：会产生大量不连续的内存碎片。2.**效率问题**，两个阶段效率都不高。

**标记整理**，一般用于老年代的垃圾回收。首先从根集合进行扫描，把存活的对象进行标记。标记完成后把存活的对象移动到堆的一端，把剩余的对象清除。

**分代收集**：根据对象存活周期的不同把Java堆分为新生代和老年代。每次垃圾收集时新生代都会有大量对象死亡。此时利用复制算法将Eden区和from survivor区还存活的对象一并复制到to survivor区。老年代的对象存活率高，没有额外空间进行分配担保，因此采用标记-清除或者标记-整理的算法进行回收。前者会产生空间碎片，而后者不会。

## 说一说垃圾收集器？各有什么特点。

   ![1564542444972](C:\Users\home.11\AppData\Roaming\Typora\typora-user-images\1564542444972.png)

**并发和并行的区别：有没有用户线程的参与。并发可以与用户线程一起工作。并行只是说多条垃圾回收线程一起工作。**

### Serial 收集器（单线程）

   ![1564542452733](C:\Users\home.11\AppData\Roaming\Typora\typora-user-images\1564542452733.png)

它是单线程的收集器，只会使用一个线程进行垃圾收集工作。它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。

### ParNew 收集器（并行）

   ![1564542458849](C:\Users\home.11\AppData\Roaming\Typora\typora-user-images\1564542458849.png)

Serial 收集器的多线程版本。

它是 Server 场景下默认的新生代收集器，**只有它能与 CMS 配合使用**。

### Parallel Scavenge 收集器（并行、可控制的吞吐量）

它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。适合在后台运算而**不需要太多交互**的任务。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

用以控制最大GC停顿时间的-XX:MaxGCPauseMillis及直接控制吞吐量的参数-XX:GCTimeRatio。可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics）。

### Serial Old 收集器（Serial 老年代版）

 ![1564542465805](C:\Users\home.11\AppData\Roaming\Typora\typora-user-images\1564542465805.png)

   

是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：

在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。

作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

###  Parallel Old 收集器（Parallel Scavenge 老年代版）

   ![1564542470968](C:\Users\home.11\AppData\Roaming\Typora\typora-user-images\1564542470968.png)

是 Parallel Scavenge 收集器的老年代版本。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### CMS 收集器（并发、低停顿、标记 - 清除）

   ![1564542476449](C:\Users\home.11\AppData\Roaming\Typora\typora-user-images\1564542476449.png)

（Concurrent Mark Sweep）Mark Sweep 指的是标记 - 清除算法。

分为以下四个流程：

1. 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。

2. 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。

3. 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。

4. 并发清除：不需要停顿。


在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

具有以下缺点：

1. 由于是基于标记-清除算法，所以会产生**空间碎片**

2. 无法处理**浮动垃圾**，即在清理期间由于用户线程还在运行，还会持续产生垃圾，而这部分垃圾还没有被标记，在本次无法进行回收。

3. 对**CPU**资源敏感，低停顿时间是以**牺牲吞吐量**为代价的，导致 CPU 利用率不够高。


CMS比较类似适合用户交互的场景，可以获得较小的响应时间。

 

###  G1 收集器（Region 、可预测的停顿）

   ![1564552046265](C:\Users\home.11\AppData\Roaming\Typora\typora-user-images\1564552046265.png)![1564552055688](C:\Users\home.11\AppData\Roaming\Typora\typora-user-images\1564552055688.png)

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，**使得可预测的停顿时间模型成为可能。**通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个**优先列表**，每次根据允许的收集时间，优先回收价值最大的 Region。每个 Region 都有一个 **Remembered Set**，用来记录该 Region 对象的引用对象所在的 Region。通过使用Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

1. 初始标记：标记与GC Roots直接关联的对象，会暂停用户线程（Stop the World）

2. 并发标记：并发从GC Roots开始找出存活的对象，可以和用户线程一起进行

3. 最终标记：修正并发标记期间因用户程序继续运作导致标记产生变动的对象的标记记录

4. 筛选回收：清除标记阶段中确定为不可达的对象，具体来说对各个区域的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。

具备如下特点：

**空间整合**：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。

**可预测的停顿**：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

G1的优势：可预测的停顿；实时性较强，大幅减少了长时间的gc；一定程度的高吞吐量。

 

## CMS和G1的区别？

由上一个问题可总结出CMS和G1的区别：

- G1堆的**内存布局**和其他垃圾收集器不同，它将整个Java堆划分成多个大小相等的独立区域(Region)。G1依然保留了分代收集，但是新生代和老年代不再是物理隔离的，它们都属于一部分Region的集合，因此仅使用G1就可以管理整个堆。

- **算法不同，以及会不会产生空间碎片**。CMS基于标记-清除，会产生空间碎片；G1从整体看是标记-整理，从局部（两个Region之间）看是复制算法，不会产生空间碎片。

- G1能实现可预测的停顿。

  

# 对象与类

## 对象的创建？![对象创建](C:\Users\home.11\Desktop\小a笔记\images\对象创建.png)



**①类加载检查：**首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须**先执行相应的类加载过程。**

**②分配内存：** 对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

**③初始化零值：** 将分配到的内存空间都初始化为零值（对象头在下一部初始化），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用。与类加载的初始化零值区别在于，类加载初始化是执行<clinit>方法，即类中所有类变量的赋值动作和static{}，调用前会先执行父类的<clinit>方法。而对象初始化的<init>方法即我们自己写的构造函数，调用前会先执行父类的<init>构造函数。

**④设置对象头：**例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

**⑤执行 init 方法：** 执行`<init>` 构造方法。



## 对象的内存布局![多线程概念](C:\Users\home.11\Desktop\小a笔记\images\多线程概念.png)



**对象头**：**Hotspot虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的自身运行时数据**（哈希吗、GC分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。Mark Word（标记字段）、Klass Pointer（类型指针）、数组长度数据（可选）

**实例数据：是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

**对齐填充**：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据**不是必须的**，仅仅是为了字节对齐；



## 对象的访问定位

建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：

1. **句柄：** 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，**reference 中存储的就是对象的句柄地址**，而句柄中包含了对象实例数据与类型数据各自的具体地址信息； 

   ![使用句柄](https://user-gold-cdn.xitu.io/2018/4/27/16306b9573968946?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

   

2. **直接指针：**  如果使用直接指针访问，那么 Java 堆对像的布局中就必须考虑如何防止放置类型数据的相关信息（如对象的类型，实现的接口、方法、父类、field等），**reference 中存储的直接就是对象的地址。**



![使用直接指针](https://user-gold-cdn.xitu.io/2018/4/27/16306ba3a41b6b65?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动后（垃圾收集时移动对象是非常普遍的行为），**只会改变句柄中的实例数据指针，而 reference 本身不需要修改**。使用直接指针访问方式最大的好处就是速度快，**它节省了一次指针定位的时间开销。**

**对于HotSpot虚拟机来说，使用的就是直接指针访问的方式。**

## 介绍下类加载器和类加载过程？

**先说类加载器**。

在Java中，系统提供了三种类加载器。

- 启动类加载器（Bootstrap ClassLoader），启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要委派给启动类加载器，直接使用null。

- 扩展类加载器（Extension ClassLoader）

- 应用程序类加载器（Application ClassLoader），负责加载用户类路径（ClassPath）上锁指定的类库。是程序中默认的类加载器。


当然用户也可以自定义类加载器。

**再说类加载的过程**。

主要是以下几个过程：

**加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载**

**加载**

1. 通过一个类的全限定名获取定义该类的二进制字节流

2. 将字节流表示的静态存储结构转化为方法区的运行时数据结构

3. 在内存中生成这个类的Class对象，作为方法区这个类的各种数据的访问入口


**验证**

- 文件格式验证：比如检查是否以魔数0xCAFEBABE开头

- 元数据验证：对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。比如检查该类是否继承了被final修饰的类。

- 字节码验证，通过数据流和控制流的分析，验证程序语义是合法的、符合逻辑的。


**准备**。 为类变量（static）分配内存并设置默认值。比如static int a = 123在准备阶段的默认值是0，但是如果有final修饰，在准备阶段就会被赋值为123了。

**解析**。将常量池中的符号引用替换成直接引用的过程。包括类或接口、字段、类方法、接口方法的解析。

**初始化**。按照程序员的计划初始化类变量。如static int a = 123，在准备阶段a的值被设置为默认的0，而到了初始化阶段其值被设置为123。

## 什么是双亲委派模型，有什么好处？如何打破双亲委派模型？

类加载器之间满足双亲委派模型，即：除了顶层的启动类加载器外，其他所有类加载器都必须要自己的父类加载器。当一个类加载器收到类加载请求时，自己首先不会去加载这个类，而是不断把这个请求委派给父类加载器完成，因此所有的加载请求最终都传递给了顶层的启动类加载器。只有当父类无法完成这个加载请求时，子类加载器才会尝试自己去加载。

双亲委派模型的好处？使得**Java的类随着它的类加载器一起具备了一种带有优先级的层次关系**。Java的Object类是所有类的父类，因此无论哪个类加载器都会加载这个类，因为双亲委派模型，所有的加载请求都委派给了顶层的启动类加载器进行加载。所以Object类在任何类加载器环境中都是同一个类。

如何打破双亲委派模型？使用OSGi可以打破。*OSGI*(Open Services Gateway Initiative)，或者通俗点说JAVA动态模块系统。可以实现代码热替换、模块热部署。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。

## jvm笔试题所得

03月份刷java笔试真题记录

**编译器javac.exe**编译，Test.java生成Test.class字节码文件.(如果一个文件中有多个类那么就会有多个.class字节码文件)**解释器java.exe**解释把.class字节码文件执行

下面两段代码都做同样的事，哪段效率更高？

```java
for (int i = 0; i < 1000; i++) {   Object o=new Object(); }
```

```java
Object o;for (int i = 0; i < 1000; i++) {    o = new Object();}
```


代码块1中，每一次循环就需要在栈中分配一个储存空间给x使用，这次循环结束后，x的作用域就结束了，需要回收x占有的栈空间。代码块2中，只需要一次在栈中分配存储空间给object使用。因此答案是代码块2效率更高。

String被设计为不可变量原因:

节省空间:在lava语言中,为了提供效率与空间使用率,把字符串常量存储在 String pool(池)中,这些字符串可以被共享,

提高效率:正是由于 String会被不同的用户共享,在多线程编程时, String可能会被不同的线程共享,如果把 String设计为不可变量,为了保证一个用户对字符串的修改不会影响到其他用户，可以显著提高多线程的效率。

此外, String会经常被当作 HashMap的key进行存储,也就需要计算 String的hash值,如果 String被设计为不可变量,它的hash值也会保持不变,就可以把它的hash值缓存起来,而不用每次都计算hash值。

请问最后四行分别输出什么？

```java
String s = "Hello";
String t = "Hello";
char c[]={'H','e','l','l','o'};
System.out.println(s.equals(t));
System.out.println(t.equals(c));
System.out.println(s==t);
System.out.println(t.equals(new String("Hello")));
```

equals方法是类 Object中的方法,作用是比较两个对象的引用是否相等,即是否指向同一个对象。它等价于“==”操作,。而 String类重写了 equals方法,String类的 equals方法用来判断两个引用指向的字符串的内容是否相等,如果相等,则返回true,否则,返回 false倒数第三行。t是 String的对象,而c是字符数组的引用。 equals方法的参数为 String类型,因此,会默认调用c的 toString方法,这个方法会返回c对象的信息,而不是“Hello”,故返回值为 false。答案是：truefalsetruetrue

```
String s = "Hello world";
String t = "Hello"+new String("world");
System.out.println(s==t);
```

语句s==t的功能是比较这两个字符串的地址是否相同,显然,s存储在常量区,而st2中的“word"是在堆空间上申请的另外一块存储空间,二者必然有不同的存储地址。因此,程序的运行结果为false

想要实例化一个对象，除了new一个对象还可以怎么做？

1调用对象的clone方法

2反射

3反序列化





> [可能是把Java内存区域讲的最清楚的一篇文章](https://juejin.im/post/5b7d69e4e51d4538ca5730cb#heading-5)